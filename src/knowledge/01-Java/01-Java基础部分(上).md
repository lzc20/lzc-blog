---
order: 1
title: Java基础(上)
---
## 基础概念与常识

观看Javaguid学习笔记这是。具体请去看： [JavaGuide（Java面试+学习指南）](https://javaguide.cn/)

在我这里我只选择我自己想要记录的记录下来

#### Java 语言有哪些特点?

1. 简单易学；
2. 面向对象（封装，继承，多态）；
3. 平台无关性（ Java 虚拟机实现平台无关性）；
4. 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；
5. 可靠性（具备异常处理和自动内存管理机制）；
6. 安全性（Java 语言本身的设计就提供了多重安全防护机制如访问权限修饰符、限制程序直接访问操作系统资源）；
7. 高效性（通过 Just In Time 编译器等技术的优化，Java 语言的运行效率还是非常不错的）；
8. 支持网络编程并且很方便；
9. 编译与解释并存

#### Java SE vs Java EE

- Java SE（Java Platform，Standard Edition）: Java 平台标准版，Java 编程语言的基础，它包含了支持 Java 应用程序开发和运行的核心类库以及虚拟机等核心组件。Java SE 可以用于构建桌面应用程序或简单的服务器应用程序。
- Java EE（Java Platform, Enterprise Edition ）：Java 平台企业版，建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范（比如 Servlet、JSP、EJB、JDBC、JPA、JTA、JavaMail、JMS）。 Java EE 可以用于构建分布式、可移植、健壮、可伸缩和安全的服务端 Java 应用程序，例如 Web 应用程序。

简单来说，Java SE 是 Java 的基础版本，Java EE 是 Java 的高级版本。Java SE 更适合开发桌面应用程序或简单的服务器应用程序，Java EE 更适合开发复杂的企业级应用程序或 Web 应用程序。

除了 Java SE 和 Java EE，还有一个 Java ME（Java Platform，Micro Edition）。Java ME 是 Java 的微型版本，主要用于开发嵌入式消费电子设备的应用程序，例如手机、PDA、机顶盒、冰箱、空调等。Java ME 无需重点关注，知道有这个东西就好了，现在已经用不上了。

**Java是编译与解释共存的语言。**

#### 为什么说 Java 语言“编译与解释并存”？

其实这个问题我们讲字节码的时候已经提到过，因为比较重要，所以我们这里再提一下。

我们可以将高级编程语言按照程序的执行方式分为两种：

- **编译型**：[编译型语言open in new window](https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E8%AA%9E%E8%A8%80) 会通过[编译器open in new window](https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8)将源代码一次性翻译成可被该平台执行的机器码。一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。
- **解释型**：[解释型语言open in new window](https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80)会通过[解释器open in new window](https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8)一句一句的将代码解释（interpret）为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等。

**为什么说 Java 语言“编译与解释并存”？**

这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（`.class` 文件），这种字节码必须由 Java 解释器来解释执行。

#### AOT 有什么优点？为什么不全部使用 AOT 呢？

AOT是什么？ JDK 9 引入了一种新的编译模式 **AOT(Ahead of Time Compilation)** 。

和 JIT 不同的是，这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。

#### Java 和 C++ 的区别?

我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来。

虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：

- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。
- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。

#### Java 语言关键字有哪些？


| 分类                 | 关键字   |            |          |              |            |           |        |
| -------------------- | -------- | ---------- | -------- | ------------ | ---------- | --------- | ------ |
| 访问控制             | private  | protected  | public   |              |            |           |        |
| 类，方法和变量修饰符 | abstract | class      | extends  | final        | implements | interface | native |
|                      | new      | static     | strictfp | synchronized | transient  | volatile  | enum   |
| 程序控制             | break    | continue   | return   | do           | while      | if        | else   |
|                      | for      | instanceof | switch   | case         | default    | assert    |        |
| 错误处理             | try      | catch      | throw    | throws       | finally    |           |        |
| 包相关               | import   | package    |          |              |            |           |        |
| 基本类型             | boolean  | byte       | char     | double       | float      | int       | long   |
|                      | short    |            |          |              |            |           |        |
| 变量引用             | super    | this       | void     |              |            |           |        |
| 保留字               | goto     | const      |          |              |            |           |        |

![移位运算总结](01-Java基础部分.assets/1705206315386.png)

#### continue、break 和 return 的区别是什么？

在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：

1. `continue`：指跳出当前的这一次循环，继续下一次循环。
2. `break`：指跳出整个循环体，继续执行循环下面的语句。

`return` 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：

1. `return;`：直接使用 return 结束方法执行，用于没有返回值函数的方法
2. `return value;`：return 一个特定值，用于有返回值函数的方法

### 基本数据类型

#### Java 中的几种基本数据类型了解么？

Java 中有 8 种基本数据类型，分别为：

- 6 种数字类型：
  - 4 种整数型：`byte`、`short`、`int`、`long`
  - 2 种浮点型：`float`、`double`
- 1 种字符类型：`char`
- 1 种布尔型：`boolean`。

---

#### 基本类型VS包装类型的区别？

- **用途**：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。
- **存储方式**：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。
- **占用空间**：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。
- **默认值**：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。
- **比较方式**：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。

**为什么说是几乎所有对象实例都存在于堆中呢？** 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存

⚠️ 注意：**基本数据类型存放在栈中是一个常见的误区！** 基本数据类型的存储位置取决于它们的作用域和声明方式。如果它们是局部变量，那么它们会存放在栈中；如果它们是成员变量，那么它们会存放在堆中。

#### 包装类型的缓存机制是否了解？

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。

`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。

#### 自动装箱与自动拆箱？原理是什么？

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

装箱其实就是调用了 包装类的`valueOf()`方法，拆箱其实就是调用了 `xxxValue()`方法。

注意：**如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。**

#### 为什么浮点数运算的时候会有精度丢失的风险？

代码演示：

~~~java
float a = 2.0f - 1.9f;
float b = 1.8f - 1.7f;
System.out.println(a);// 0.100000024
System.out.println(b);// 0.099999905
System.out.println(a == b);// false
~~~

为什么会出现这个问题呢？

这个和计算机保存浮点数的机制有很大的关系。我们知道计算机是二进制的，而且计算机在表示一个数字时候宽度是有限的，无限循环小数存储在计算机时候，只能被阶段，所以会导致小鼠精度损失的情况

#### 如何解决浮点数运算精度的丢失问题？

`BigDecimal` 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 `BigDecimal` 来做的。--这个就解决了精度缺失的问题

在阿里巴巴手册当中有所提到过具体请看: [阿里巴巴开发手册下载地址](https://developer.aliyun.com/ebook/386)

### 变量

#### 成员变量与局部变量的区别？

![img](01-Java基础部分.assets/1705240411835.png)

**语法形式**：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 `public`,`private`,`static` 等修饰符所修饰，而局部变量不能被访问控制修饰符及 `static` 所修饰；但是，成员变量和局部变量都能被 `final` 所修饰。

**存储方式**：从变量在内存中的存储方式来看，如果成员变量是使用 `static` 修饰的，那么这个成员变量是属于类的，如果没有使用 `static` 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。

**生存时间**：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。

**默认值**：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

```
在Java中，
```

**成员变量**可以分为**静态成员变量**和**实例成员变量**。静态成员变量使用关键字static修饰，它属于类级别的变量，被所有的对象所共享，只会在内存中存在一份副本。而实例成员变量不使用static修饰，它属于实例级别的变量，每个对象都会拥有一份独立的副本。

对象在Java中存储在堆内存中，而成员变量也存储在堆内存中。当创建一个对象时，会为对象分配堆内存，并在堆内存中存储实例成员变量。而静态成员变量则存储在类的静态区域，无论创建多少个对象，它的值都是唯一的。

**局部变量是在方法、构造函数或代码块中定义的变量，它们存在于栈内存中**。当进入这些代码块时，会为局部变量分配内存空间，当代码块执行完毕后，这些局部变量所占用的内存空间会被自动释放。

需要注意的是，静态成员变量和实例成员变量的生命周期不同。静态成员变量在程序启动时就会创建并初始化，在整个程序运行期间都存在。而实例成员变量则是在创建对象时才会被初始化，当对象不再被引用时，会被垃圾回收器回收。

#### 为什么成员变量有默认值？

在Java中，成员变量（包括实例成员变量和静态成员变量）如果没有被显式地初始化，会被赋予默认值。这是因为Java语言规范定义了成员变量的默认初始化规则，以确保程序的可靠性和一致性。

成员变量的默认值取决于其类型，具体规则如下：

对于数值类型（byte、short、int、long、float、double）的成员变量，默认值为0。 对于char类型的成员变量，默认值为'\u0000'（空字符）。 对于boolean类型的成员变量，默认值为false。 对于引用类型（类、接口、数组等）的成员变量，默认值为null。

通过赋予成员变量默认值，可以避免在每个对象创建时都要手动初始化变量的麻烦，并且使得对象在创建后能够处于一个可用的状态。当我们需要使用成员变量时，如果没有显式地对其进行赋值，就可以使用默认值。当然，如果我们希望成员变量有特定的初始值，也可以在声明时进行显式初始化。

需要注意的是，局部变量（方法内部定义的变量）没有默认值，必须在使用之前进行显式初始化。否则编译器会报错。这是因为局部变量的生命周期比较短暂，编译器无法确定它们是否会被正确地初始化。

#### 静态变量有什么作用呢？

chatGPT告诉我们：

1. 共享数据：静态变量属于类级别，被所有对象所共享。这意味着无论创建多少个类的实例，它们都可以访问和修改同一个静态变量。这种共享数据的特性使得静态变量非常适合用于保存需要被多个对象共享的数据，例如计数器、配置信息等。
2. 在内存中只有一份副本：静态变量在程序启动时会被创建并初始化，在整个程序运行期间都存在于内存中。因此，静态变量的值在各个对象之间是共享的，无论创建多少个对象，它们都会引用同一个静态变量的副本。这样可以节省内存空间。
3. 全局访问：由于静态变量属于类，不依赖于对象的创建，因此可以在任何地方通过类名直接访问静态变量，而不需要创建对象。这使得静态变量具有全局访问的能力，可以在不同的类和方法中使用它们。例如，可以通过类名.静态变量的方式访问、修改静态变量的值。
4. 用于常量：静态变量也可以用于声明常量，使用关键字final修饰。这些常量的值在程序运行期间不可更改，一般以全大写的命名方式表示，并作为类的属性存在。静态常量可以在整个程序中使用，且值不会被修改。

总之，静态变量在Java中提供了一种在多个对象之间共享数据和提供全局访问的机制，可以节省内存空间并简化代码的编写。但需要注意的是，由于静态变量具有全局性质，过度使用可能导致代码的可维护性和可测试性下降，因此需要谨慎使用。

#### 字符常量和字符串常量的区别？

1. 数据类型：字符常量是单个字符，使用单引号 ' 包围，例如 'A'、'5'、'!'。而字符串常量是由多个字符组成的序列，使用双引号 " 包围，例如 "Hello"、"123"、"@#$"。
2. 存储方式：字符常量在内存中以整数形式存储，对应于字符的Unicode编码值。而字符串常量是以字符数组的形式存储在内存中，每个字符占用两个字节（根据UTF-16编码）。
3. 可变性：字符常量是不可变的，一旦创建就不能被修改。而字符串常量也是不可变的，一旦创建就不能修改其中的字符。但是可以通过创建新的字符串实例来修改字符串内容。
4. 比较方式：字符常量可以直接使用相等运算符（==）进行比较，判断两个字符是否相等。而字符串常量不能直接使用相等运算符进行比较，需要使用equals()方法来比较两个字符串是否相等。
5. 表示方式：字符常量可以使用转义字符表示特殊字符，例如 '\n' 表示换行符，'\t' 表示制表符。而字符串常量可以包含任意字符，包括特殊字符和Unicode字符。

总结：**字符常量表示单个字符，使用单引号包围，是基本数据类型；字符串常量表示多个字符组成的序列，使用双引号包围，是引用数据类型。字符常量是不可变的，而字符串常量也是不可变的，但可以通过创建新的字符串实例来修改字符串内容。**

### 方法

#### 什么是方法的返回值？方法有哪几种类型？

在Java中，方法的返回值可以有以下几种类型：

1. **void**：表示方法没有返回值。void关键字用于声明无返回值的方法，这种类型的方法通常被称为"无返回值方法"。在方法执行完毕后，不会返回任何结果。
2. **基本数据类型**：方法可以返回基本数据类型的值，例如int、double、boolean等。在方法声明时，需要在方法名前面指定返回值的数据类型，如：int、double等。
3. **引用数据类型**：方法也可以返回引用数据类型的值，例如数组、对象等。在方法声明时，需要在方法名前面指定返回值的数据类型，如：String、数组类型等。
4. **自定义类型**：方法还可以返回自定义的数据类型，即用户自己定义的类。在方法声明时，需要在方法名前面指定返回值的自定义类的类型。

注意：**的是，一个方法只能有一个返回值，且返回值的类型必须与方法声明中指定的返回值类型一致或兼容。如果方法声明了返回值类型，但实际执行过程中没有返回对应类型的值，则会导致编译错误**。

在方法中，使用**关键字return**加上对应类型的值来返回结果。当方法执行到return语句时，会立即结束方法的执行，并将return语句后面的值返回给调用者。

#### 静态方法为什么不能调用非静态成员？

静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。

在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

#### 静态方法和实列方法有何不同？

静态方法和实例方法是Java中两种不同类型的方法，它们具有以下不同点：

1. 调用方式不同：静态方法通过类名直接调用，而实例方法需要通过对象实例来调用。
2. 访问权限不同：在静态方法中，只能访问静态成员变量和静态方法，而在实例方法中，可以访问实例成员变量和实例方法。
3. 内存占用不同：实例方法属于对象级别的，每个对象都要占用一定的内存空间，而静态方法属于类级别的，只存在一份，所以它不占用对象的内存空间。
4. 继承性不同：当子类继承父类时，子类可以重写父类的实例方法，但无法重写父类的静态方法。另外，子类可以通过super关键字调用父类的实例方法，但不能调用父类的静态方法。
5. 能否访问非静态成员不同：在静态方法中，不能访问非静态成员（即实例成员变量和实例方法），而在实例方法中可以访问静态成员和非静态成员。

总体来说，静态方法适用于不依赖于对象状态的操作，例如工具类中的一些通用方法，而实例方法适用于需要依赖于对象状态的操作，例如访问对象属性或者执行对象特有的行为。

#### 重载和重写有什么区别？

##### 重载：

发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

##### 重写：

重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

重载（Overload）和重写（Override）是Java中的两种不同的方法实现方式，它们的区别在于：

1. 定义位置不同：重载发生在同一个类中，而重写发生在父类和子类之间。
2. 参数列表不同：重载方法的参数列表必须不同，可以是参数数量不同、参数类型不同或者参数顺序不同。而重写方法的参数列表必须相同。
3. 返回值不同：重载方法的返回值可以相同或者不同，但是必须满足参数列表不同的条件。而重写方法的返回值必须与父类方法的返回值相同或者是其子类。
4. 访问修饰符不同：重载方法可以有不同的访问修饰符，而重写方法只能与父类方法的访问修饰符相同或更为宽松。
5. 抛出异常不同：重载方法可以抛出任意的异常，而重写方法必须与父类方法抛出的异常相同或更为严格。

总体来说，重载是指在同一类中定义多个同名方法，但是它们的参数列表不同，用于处理不同的输入。而重写是指在子类中定义与父类中同名的方法，但是子类中的方法提供了具体的实现，用于实现不同的行为逻辑。在实际开发中，重载和重写都是Java中非常常见的方法实现方式，可以根据具体的应用场景进行选择。

#### 什么是可变参数？

可变参数是Java中一种用于方法参数的特殊语法，也称为可变长度参数或varargs（variable arguments）。它允许我们在调用方法时传递不定数量的参数。

在Java中，可变参数使用三个点（...）来声明，放置在方法参数列表的最后，表示该参数可以接受零个或多个值。可变参数本质上是一个数组，在方法内部可以像操作数组一样处理这些参数。

以下是可变参数的使用示例：

```Java
javaCopy Codepublic void printNumbers(int... numbers) {
    for (int number : numbers) {
        System.out.println(number);
    }
}

public static void main(String[] args) {
    MyClass myClass = new MyClass();
  
    myClass.printNumbers(1, 2, 3); // 可以传递任意数量的参数
    myClass.printNumbers(4, 5, 6, 7, 8); // 也可以传递更多的参数
    myClass.printNumbers(); // 甚至可以不传递任何参数
}
```

在上面的示例中，printNumbers() 方法使用了可变参数，可以接受任意数量的整数参数。在main()方法中，我们可以传递任意数量的参数给printNumbers()方法进行处理。

需要注意的是，可变参数必须是方法参数列表的最后一个参数。如果方法有多个参数，可变参数必须位于最后。这是因为编译器会将传递给方法的参数打包成一个数组，而其他参数会根据其位置进行匹配。
